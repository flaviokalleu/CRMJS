const express = require('express');
const router = express.Router();
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { User, Token } = require('../models');
const { Op } = require('sequelize');

const SECRET_KEY = process.env.JWT_SECRET_KEY || 'your_jwt_secret_key';
const REFRESH_SECRET_KEY = process.env.JWT_REFRESH_SECRET_KEY || 'your_jwt_refresh_secret_key';
const UPLOAD_DIR = path.resolve(__dirname, '../../uploads');

// ===== MIDDLEWARE DE PARSING PARA ESTA ROTA =====
// Adicionar middleware espec√≠fico para parsing JSON antes das rotas
router.use((req, res, next) => {
  // Se n√£o √© multipart/form-data, aplicar JSON parser
  if (!req.headers['content-type']?.includes('multipart/form-data')) {
    express.json({ limit: '50mb' })(req, res, (err) => {
      if (err) return next(err);
      express.urlencoded({ extended: true, limit: '50mb' })(req, res, next);
    });
  } else {
    next();
  }
});

// ===== CONFIGURA√á√ÉO DO MULTER =====
const getUploadPath = (user) => {
  let folder = 'imagem_user';
  
  if (user?.is_administrador) {
    folder = 'imagem_administrador';
  } else if (user?.is_correspondente) {
    folder = 'imagem_correspondente';
  } else if (user?.is_corretor) {
    folder = 'corretor';
  }
  
  return folder;
};

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    // Determinar pasta baseado no usu√°rio atual ou tipo
    let uploadPath;
    
    if (req.user) {
      uploadPath = getUploadPath(req.user);
    } else {
      // Fallback para uploads gen√©ricos
      uploadPath = 'imagem_user';
    }
    
    const fullPath = path.join(UPLOAD_DIR, uploadPath);
    
    // Criar diret√≥rio se n√£o existir
    if (!fs.existsSync(fullPath)) {
      fs.mkdirSync(fullPath, { recursive: true });
    }
    
    console.log(`üìÅ Upload destino: ${fullPath}`);
    cb(null, fullPath);
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const originalName = path.parse(file.originalname).name;
    const extension = path.extname(file.originalname);
    const filename = `${timestamp}_${originalName}${extension}`;
    
    console.log(`üìÑ Arquivo gerado: ${filename}`);
    cb(null, filename);
  },
});

const fileFilter = (req, file, cb) => {
  // Verificar se √© uma imagem
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('Apenas arquivos de imagem s√£o permitidos'), false);
  }
};

const upload = multer({ 
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB limite
  }
});

// ===== FUN√á√ïES HELPER =====
const getUserRole = (user) => {
  if (user.is_administrador) return 'Administrador';
  if (user.is_corretor) return 'Corretor';
  if (user.is_correspondente) return 'Correspondente';
  return 'User';
};

const getExpirationDate = (minutes) => {
  return new Date(Date.now() + minutes * 60000);
};

const generateTokens = (user, role) => {
  const payload = {
    id: user.id,
    email: user.email,
    role,
    is_corretor: user.is_corretor,
    is_correspondente: user.is_correspondente,
    is_administrador: user.is_administrador
  };

  return {
    token: jwt.sign(payload, SECRET_KEY, { expiresIn: '1h' }),
    refreshToken: jwt.sign(payload, REFRESH_SECRET_KEY, { expiresIn: '7d' })
  };
};

// ===== MIDDLEWARE DE AUTENTICA√á√ÉO =====
const authenticateToken = async (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ message: 'Token n√£o fornecido' });
  }

  try {
    const tokenRecord = await Token.findOne({ where: { token } });
    if (!tokenRecord || new Date() > tokenRecord.expires_at) {
      return res.status(401).json({ message: 'Token inv√°lido ou expirado' });
    }

    jwt.verify(token, SECRET_KEY, async (err, decoded) => {
      if (err) {
        return res.status(403).json({ message: 'Falha na autentica√ß√£o do token' });
      }
      
      // Buscar usu√°rio completo no banco
      const user = await User.findByPk(decoded.id);
      if (!user) {
        return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });
      }
      
      req.user = {
        ...decoded,
        ...user.toJSON()
      };
      next();
    });
  } catch (error) {
    console.error('Erro ao verificar o token:', error);
    res.status(500).json({ message: 'Erro interno do servidor' });
  }
};

// ===== ROTAS DE AUTENTICA√á√ÉO =====

// Rota de login - CORRIGIDA
router.post('/login', async (req, res) => {
  console.log('üîê Tentativa de login recebida');
  console.log('üìã Headers:', req.headers);
  console.log('üì¶ Body:', req.body);
  
  if (!req.body) {
    console.error('‚ùå req.body √© undefined');
    return res.status(400).json({ 
      error: 'Dados n√£o recebidos', 
      message: 'Verifique se o Content-Type est√° correto' 
    });
  }

  const { email, password } = req.body;

  if (!email || !password) {
    console.error('‚ùå Email ou senha n√£o fornecidos');
    return res.status(400).json({ 
      error: 'Email e senha s√£o obrigat√≥rios.',
      received: { email: !!email, password: !!password }
    });
  }

  try {
    console.log(`üîç Buscando usu√°rio: ${email}`);
    const user = await User.findOne({ where: { email } });

    if (!user) {
      console.error('‚ùå Usu√°rio n√£o encontrado');
      return res.status(401).json({ error: 'Credenciais inv√°lidas' });
    }

    console.log('üîí Verificando senha...');
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      console.error('‚ùå Senha inv√°lida');
      return res.status(401).json({ error: 'Credenciais inv√°lidas' });
    }

    const role = getUserRole(user);
    const { token, refreshToken } = generateTokens(user, role);

    console.log('üíæ Salvando token no banco...');
    
    try {
      // Primeiro, remover tokens antigos do usu√°rio
      await Token.destroy({
        where: { 
          user_id: user.id 
        }
      });

      // Depois, criar novo token
      await Token.create({
        token,
        refresh_token: refreshToken,
        user_id: user.id,
        user_type: role,
        expires_at: getExpirationDate(60), // 1 hora
        email: user.email,
        created_at: new Date(),
        updated_at: new Date()
      });

      console.log('‚úÖ Token salvo com sucesso');
    } catch (tokenError) {
      console.error('üí• Erro ao salvar token:', tokenError);
      
      // Se falhar ao salvar token, tentar novamente sem refresh_token duplicado
      try {
        await Token.destroy({
          where: { 
            [Op.or]: [
              { user_id: user.id },
              { token },
              { refresh_token: refreshToken }
            ]
          }
        });

        await Token.create({
          token,
          refresh_token: refreshToken,
          user_id: user.id,
          user_type: role,
          expires_at: getExpirationDate(60),
          email: user.email,
          created_at: new Date(),
          updated_at: new Date()
        });

        console.log('‚úÖ Token salvo na segunda tentativa');
      } catch (secondError) {
        console.error('üí• Erro cr√≠tico ao salvar token:', secondError);
        return res.status(500).json({ 
          error: 'Erro interno do servidor ao processar login' 
        });
      }
    }

    console.log('‚úÖ Login realizado com sucesso');
    res.json({
      token,
      refreshToken,
      user: {
        id: user.id,
        email: user.email,
        role,
        first_name: user.first_name,
        last_name: user.last_name,
        is_corretor: user.is_corretor,
        is_correspondente: user.is_correspondente,
        is_administrador: user.is_administrador
      }
    });
  } catch (error) {
    console.error('üí• Erro ao autenticar:', error);
    res.status(500).json({ 
      error: 'Erro interno do servidor',
      message: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Rota para refresh de token
router.post('/refresh-token', async (req, res) => {
  console.log('üîÑ Refresh token solicitado');
  
  if (!req.body) {
    return res.status(400).json({ message: 'Dados n√£o recebidos' });
  }

  const { refreshToken } = req.body;

  if (!refreshToken) {
    return res.status(401).json({ message: 'Refresh token n√£o fornecido' });
  }

  try {
    const tokenRecord = await Token.findOne({ where: { refresh_token: refreshToken } });
    if (!tokenRecord || new Date() > tokenRecord.expires_at) {
      return res.status(403).json({ message: 'Refresh token inv√°lido ou expirado' });
    }

    jwt.verify(refreshToken, REFRESH_SECRET_KEY, async (err, user) => {
      if (err) {
        return res.status(403).json({ message: 'Falha na autentica√ß√£o do refresh token' });
      }

      const { token: newToken } = generateTokens(user, user.role);
      
      await Token.update(
        { 
          token: newToken,
          expires_at: getExpirationDate(60),
          updated_at: new Date()
        },
        { where: { refresh_token: refreshToken } }
      );

      return res.json({ token: newToken });
    });
  } catch (error) {
    console.error('Erro ao verificar o refresh token:', error);
    res.status(500).json({ message: 'Erro interno do servidor' });
  }
});

// Rota para validar o token
router.post('/validate-token', authenticateToken, (req, res) => {
  res.json({ 
    valid: true,
    user: {
      id: req.user.id,
      email: req.user.email,
      role: req.user.role
    }
  });
});

// Get user profile - melhorada
router.get('/me', authenticateToken, async (req, res) => {
  try {
    const user = await User.findByPk(req.user.id, {
      attributes: { exclude: ['password'] }
    });
    
    if (!user) {
      return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });
    }

    const role = getUserRole(user);
    res.json({
      user: user.toJSON(),
      type: role,
      role: role.toLowerCase()
    });
  } catch (error) {
    console.error('Erro ao buscar perfil:', error);
    res.status(500).json({ message: 'Erro interno do servidor' });
  }
});

// Nova rota para verificar autentica√ß√£o automaticamente - CORRIGIDA
router.get('/check-auth', async (req, res) => {
  console.log('üîç Verificando autentica√ß√£o...');
  
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  console.log('üìù Token recebido:', token ? `${token.substring(0, 20)}...` : 'Nenhum');

  if (!token) {
    console.log('‚ùå Nenhum token fornecido');
    return res.status(401).json({ 
      authenticated: false, 
      message: 'Token n√£o fornecido' 
    });
  }

  try {
    // 1. Verificar se o token existe no banco de dados
    console.log('üîç Buscando token no banco...');
    const tokenRecord = await Token.findOne({ 
      where: { token },
      include: [{
        model: User,
        as: 'user',
        attributes: { exclude: ['password'] }
      }]
    });

    if (!tokenRecord) {
      console.log('‚ùå Token n√£o encontrado no banco');
      return res.status(401).json({ 
        authenticated: false, 
        message: 'Token n√£o encontrado' 
      });
    }

    // 2. Verificar se o token n√£o expirou
    const now = new Date();
    if (now > tokenRecord.expires_at) {
      console.log('‚ùå Token expirado:', {
        now: now.toISOString(),
        expires: tokenRecord.expires_at.toISOString()
      });
      
      // Remover token expirado
      await Token.destroy({ where: { token } });
      
      return res.status(401).json({ 
        authenticated: false, 
        message: 'Token expirado' 
      });
    }

    // 3. Verificar se o token JWT √© v√°lido
    jwt.verify(token, SECRET_KEY, async (err, decoded) => {
      if (err) {
        console.log('‚ùå Token JWT inv√°lido:', err.message);
        
        // Remover token inv√°lido
        await Token.destroy({ where: { token } });
        
        return res.status(401).json({ 
          authenticated: false, 
          message: 'Token inv√°lido' 
        });
      }
      
      // 4. Buscar usu√°rio atual
      const user = await User.findByPk(decoded.id, {
        attributes: { exclude: ['password'] }
      });
      
      if (!user) {
        console.log('‚ùå Usu√°rio n√£o encontrado:', decoded.id);
        
        // Remover token de usu√°rio inexistente
        await Token.destroy({ where: { token } });
        
        return res.status(404).json({ 
          authenticated: false, 
          message: 'Usu√°rio n√£o encontrado' 
        });
      }

      // 5. Atualizar √∫ltimo acesso
      await Token.update(
        { 
          updated_at: new Date(),
          // Opcional: estender tempo de vida do token
          expires_at: getExpirationDate(60) // +1 hora
        },
        { where: { token } }
      );

      const role = getUserRole(user);
      
      console.log('‚úÖ Token v√°lido para usu√°rio:', user.email);
      
      res.json({
        authenticated: true,
        user: user.toJSON(),
        type: role,
        role: role.toLowerCase(),
        token, // Retornar o mesmo token
        expiresAt: tokenRecord.expires_at
      });
    });
  } catch (error) {
    console.error('üí• Erro ao verificar autentica√ß√£o:', error);
    res.status(500).json({ 
      authenticated: false, 
      message: 'Erro interno do servidor' 
    });
  }
});

// Get user by email
router.get('/users/:email', authenticateToken, async (req, res) => {
  try {
    const { email } = req.params;
    
    if (req.user.email !== email && !req.user.is_administrador) {
      return res.status(403).json({ message: 'Acesso negado' });
    }

    const user = await User.findOne({ 
      where: { email },
      attributes: { exclude: ['password'] }
    });
    
    if (!user) {
      return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });
    }

    res.json(user);
  } catch (error) {
    console.error('Erro ao buscar usu√°rio por email:', error);
    res.status(500).json({ message: 'Erro interno do servidor' });
  }
});

// Update user profile
router.put('/users/:email', authenticateToken, upload.single('photo'), async (req, res) => {
  console.log('üìù Atualizando perfil do usu√°rio');
  console.log('üì¶ Body:', req.body);
  console.log('üìÑ File:', req.file);
  
  const { email } = req.params;
  
  try {
    const user = await User.findOne({ where: { email } });
    if (!user) {
      return res.status(404).json({ message: 'Usu√°rio n√£o encontrado' });
    }

    // Verificar permiss√µes
    if (req.user.email !== email && !req.user.is_administrador) {
      return res.status(403).json({ message: 'Sem permiss√£o para atualizar este usu√°rio' });
    }

    const updateData = { ...req.body };

    // Hash da senha se fornecida
    if (updateData.password) {
      console.log('üîí Atualizando senha...');
      const salt = await bcrypt.genSalt(10);
      updateData.password = await bcrypt.hash(updateData.password, salt);
    }

    // Processar upload de foto
    if (req.file) {
      console.log('üì∏ Processando upload de foto...');
      const uploadPath = getUploadPath(user);
      updateData.photo = req.file.filename;
      
      console.log(`‚úÖ Foto salva: ${uploadPath}/${req.file.filename}`);
    }

    await user.update(updateData);
    
    console.log('‚úÖ Perfil atualizado com sucesso');
    res.json({ 
      message: 'Perfil atualizado com sucesso',
      photo: updateData.photo ? {
        filename: updateData.photo,
        url: `${req.protocol}://${req.get('host')}/api/uploads/${getUploadPath(user)}/${updateData.photo}`
      } : undefined
    });
  } catch (error) {
    console.error('üí• Erro ao atualizar perfil:', error);
    res.status(500).json({ 
      message: 'Erro interno do servidor',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Logout route
router.post('/logout', authenticateToken, async (req, res) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    await Token.destroy({ where: { token } });
    res.json({ message: 'Logout realizado com sucesso' });
  } catch (error) {
    console.error('Erro ao fazer logout:', error);
    res.status(500).json({ message: 'Erro interno do servidor' });
  }
});

// Rota de teste para debug
router.get('/test', (req, res) => {
  res.json({
    message: 'Auth routes funcionando',
    timestamp: new Date().toISOString(),
    uploadDir: UPLOAD_DIR
  });
});

module.exports = { router, authenticateToken };